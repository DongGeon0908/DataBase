# SQL 명령어를 실행할 대상인 기본 데이터베이스를 univDB로 지정
use univDB;

# safe mode 해제
SET SQL_SAFE_UPDATES =0;

/* 트랜잭션
- 관련 SQL 문장들을 묶어서 하나의 처리 단위로 다룸
- 한 묶음으로 처리되어야 하는 SQL 명령문들의 집합
- 전체 SQL 완료시 처리, 하나라도 실패시 전체 실패

커밋 commit
트랜잭션의 실행 결과를 데이터베이스에 최종적으로 반영하는 것
임시로 시행 처리한 트랜잭션의 실행 결과를 실제 데이터베이스에 반영한 명령

롤백 rollback
실행 결과를 반영하지 않고 취소해 원래 상태로 되돌리는 것

- 복수 사용자의 동시 접근성을 제어하고 장애 발생 시 안정적으로 데이터를 복구하기 위해 사용

원자성 Atomivity
트랜잭션 안의 SQL 명령문을 모두 성공적으로 실행해 완료하거나 모두 철회해 무효화시키는 것
전부 혹은 전무 실행 규칙

일관성 Consistency
데이터베이스가 트랜잭션 실행 전의 일관된 상태에서 트랜잭션 실행 후에도 또 다른 일관된 상태로 전환되어야함
트랜잭션 시작 전과 커밋 후에도 항상 데이터의 일관성 유지 
동시 실행되는 트랜잭션 사이의 상호 간섭을 락과 같은 수단을 통해 제어함으로써 데이터의 일관성 유지

고립성 Isolation
커밋될 때까지 트랜잭션이 수행한 임시 실행 결과가 다른 트랜잭션에게 공개되지 않아야함을 의미
같은 데이터를 처리하려는 다른 트랜잭션들의 간섭 방지
락을 통해 고립시켜 다른 트랜잭션의 접근 방지

지속성 Durability
트랜잭션이 커밋되면 그 트랜잭션의 실행 결과는 장애가 발생하더라도 보존되어야 함
커밋된 트랜잭션의 결과는 최종적으로 안정된 저장 장치에 반영되는 것을 보장, 결코 손상되지 않음
로그 등의 실행 기록을 참조해 이전 상태로 회복 가능

원자성, 일관성, 고립성, 지속성 등은 트랜잭션이 항상 만족해야 하는 필수 조건
*/

/* 트랜잭션 지원 DBMS 모듈

동시성 제어 concurrency control 모듈
- 동시에 실행되는 트랜잭션 간의 간섭 제어
- 각 트랜잭션이 순차적으로 실행한 결과와 동일한 고립성 결과를 보장
- 트랜잭션 실행 이전과 이후의 데이터베이스 일관성이 항상 유지
- 락킹 locking

회복 recovery 모듈
- 완전한 트랜잭션 결과의 복구 보장
- 장애 발생 시 트랜잭션 실행의 원자성 보장
- 커밋된 트랜잭션의 결과는 반드시 데이터베이스에 반영되도록 지속성 지원
- 로깅 logging
*/

/* 명시적 트랜잭션 == 사용자 트랜잭션 == 수동 트랜잭션
- 트랜잭션의 시작과 끝을 사용자가 직접 명시적으로 저장하는 트랜잭션

start transaction
- 직접 트랜잭션의 시작을 지시
- 명시적 트랜잭션 시작
- 기본 모드인 자동 모드 상태에서 수동 모드 상태로 전환

commit 
- 트랜잭션의 처리 결과를 성적으로 완료
- 변경 내용을 모두 실제 데이터베이스에 영구적으로 반영
- 트랜잭션 동작을 종료하고 다시 자동 모드 상태로 전환

rollback
- 트랜잭션 처리 내용을 취소하고 트랜잭션 시작 이전의 원래 상태로 되돌림
- 트랜잭션 시작 이전의 원래 상태로 되돌림
*/

# 명시적 트랜잭션의 적용 예
start transaction;
	delete from 학생 where 성별 = '남';
    select * from 학생;
rollback;
select * from 학생;

/* 자동완료 트랜잭션 == 시스템 트랜잭션
- 특별한 설정이 없을 경우 적용되는 기본 모드의 트랜잭션
- 데이터베이스를 변경시키는 SQL문 하나를 독립된 하나의 트랜잭션으로 자동 정의
- SQL문의 실행 결과에 따라 자동으로 커밋 또는 롤백하는 트랜잭션
*/

# 자동완료 트랜잭션의 설정 -> 하나의 SQL명령문마다 개별 트랜잭션 처리
select @@autocommit;
set autocommit = 1;

# 자동완료 트랜잭션의 적용 예
insert into 과목 values ('c007', '영어회화', '333', '교양학부', 3);
select * from 과목;
rollback;
select * from 과목;

/* 수동완료 트랜잭션 == 암시적 트랜잭션
- 트랜잭션의 끝만 사용자가 직접 명시적으로 지정한 트랜잭션
- 트랜잭션의 시작은 자동으로 실행
*/

# 수동완료 트랜잭션의 설정 -> commit 명령문이나 rollback 명령문은 반드시 명세
select @@autocommit;
set autocommit = 0;

# 수동완료 트랜잭션의 적용 예
delete from 과목 where 이름 = '연극학개론';
select * from 과목;
	insert into 과목 values ('c008', '독서와토론', '111', '교양학부', 2);
select * from 과목;
rollback;
select * from 과목;
set autocommit = 1;

/* 트랜잭션과 로그
로그 회복
장애 발생에 대한 안전한 복구를 지원하기 위한 대표적 기법

지연 쓰기 전략
버퍼 캐시 안의 페이지들을 다시 요청하는 경우를 위해 디스크 입출력 횟수를 최대한 줄여 성능을 향상시키기 위함
*/

/* 로그 먼저 쓰기 규약 write-ahead log protocl
버퍼 캐시 페이지들은 즈각적으로 디스크에 반영하지 않더라도 트랜잭션 실행 기록인 로그는 매번 트랜잭션 처리 직전에 먼저 디스크 안의 로그 데이터베이스 파일에 안전하게 기록
*/

/* 로그 데이터베이스
트랜잭션의 모든 데이터 변경 사항을 저장 데이터베이스 파일에 반영하기 전에 미리 기록하는 특별한 데이터베이스

로그
추후 복구를 위해 저장하는 트랜잭션 처리 정보
*/

/* 백업 데이터베이스
데이터베이스 파일의 물리적 손상에 대비해 별도로 저장한 복제 데이터베이스

전체 백업
전체 데이터베이스의 복사본을 저장

차등 백업
변경 데이터 부분만 추가로 백업

증분 백업
전체 데이터베이스 복사본과 이후의 로그 데이터베이스 복사본을 저장

복원
백업 데이터베이스를 사용해 원래 상태로 되돌리는 작업
*/

/* 트랜잭션 로그
- 로그를 통한 회복의 기본 단위는 트랜잭션
- 트랜잭션 로그를 로그 데이터베이스 파일에 저장

트랜잭션 식별자, start, commit, rollback, 명령문 유형과 변경 내용들이 기록
*/

# 트랜잭션 로그의 예
[ T1, START ]
[ T1, UPDATE, 학생(김연아), 중간성적, 88, 99 ]
[ CHECKPOINT ]
[ T1, UPDATE, 학생(이영애), 중간성적, 91, 97 ]
[ T1, COMMIT ]

/* 체크 포인트 == 검사점
- 특정 시점까지의 데이터 버퍼 안의 모든 변경 내용을 데이터베이스 파일에 물리적으로 저장하는 시저
- 체크 포인트가 트랜잭션 로그에 기록되는 순간 모든 데이터 버퍼 안의 데이터들이 데이터베이스 파일에 기록
*/

/* 로그를 이용한 회복 기법

회복
- 장애 발생 시점에 이미 커밋된 트랜잭션의 변경 내용은 로그를 이용해 반드시 데이터베이스에 반영한다는 것
- 커밋되지 못하고 중단된 트랜잭션의 샐행 결과는 철회

롤백 -> 로그 기록의 역순으로 이전 상태로 되돌리는 취소 작업

- 실행 순서의 역순으로 취소

- 로그 기록의 순서대로 다시 실행하는 재실행 작업

롤포워드 - 로그순서대로 재실행

- 체크포인트 이후의 실행 결과는 데이터베이스 파일에 반영된 결과과 있다면 선택적으로 취소
- 체크포인트 이전의 실행 결과는 반드시 취소
*/

/* 락 잠금
- 다중 사용자 환경에서 동시 접근을 올바르게 제어하기 위한 대표적 기법

바람직한 동시성
2개 이상의 트랜잭션을 동시에 실행하는 비직렬 스케쥴의 결과가 트랜잭션을 뒤섞지 않고 순차적으로 실행하는 직렬 스케쥴의 결과와 같도록 보장하는 것

- 직렬 가능 -> 바람직한 동시성을 보장하는 트랜잭션 스케쥴

락 == 잠금
- 데이터베이스의 데이터를 다른 사용자가 접근하지 못하도록 잠그는 것
- 다수 트랜잭션의 동시 처리를 보장하는 동시성 제어 기법
*/